<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Meme Generator — Tools Jet</title>
  <style>
    :root{
      --blue:#0d6efd; /* bright blue */
      --blue-600:#0b5ed7;
      --bg:#ffffff;
      --muted:#666;
      --radius:12px;
    }
    *{box-sizing:border-box}
    body{font-family:Inter,system-ui,Arial,sans-serif;margin:0;background:linear-gradient(180deg,#f7fbff, #ffffff);color:#111}
    .app{max-width:1100px;margin:28px auto;padding:20px}
    .card{background:var(--bg);border-radius:16px;box-shadow:0 6px 24px rgba(13,110,253,0.06);padding:18px}
    header{display:flex;align-items:center;gap:12px;margin-bottom:16px}
    .logo{display:flex;align-items:center;gap:10px}
    .logo .dot{width:36px;height:36px;border-radius:8px;background:var(--blue);display:inline-block}
    h1{font-size:18px;margin:0}
    p.lead{margin:6px 0 0;color:var(--muted);font-size:13px}

    .controls{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px}
    .btn{background:var(--blue);color:#fff;padding:10px 14px;border-radius:10px;border:0;cursor:pointer;font-weight:600}
    .btn.ghost{background:transparent;color:var(--blue);border:2px solid rgba(13,110,253,0.12)}
    .file-input{display:flex;align-items:center;gap:8px}
    input[type=file]{display:none}
    label.file-label{background:linear-gradient(90deg,var(--blue),var(--blue-600));color:#fff;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}

    .workspace{display:grid;grid-template-columns:1fr 360px;gap:16px;margin-top:18px}

    /* Canvas area */
    .canvas-wrap{background:#f3f7ff;border-radius:12px;padding:12px;display:flex;align-items:center;justify-content:center;min-height:320px;position:relative}
    canvas#imageCanvas{max-width:100%;height:auto;border-radius:10px;display:block}

    /* overlay: selection rectangle */
    .overlay{position:absolute;left:12px;top:12px;right:12px;bottom:12px;border-radius:10px;pointer-events:none}

    /* Sidebar */
    .sidebar{padding:12px}
    .preview{background:#fff;border-radius:10px;padding:10px;border:1px dashed rgba(0,0,0,0.06);display:flex;align-items:center;justify-content:center}
    canvas#previewCanvas{max-width:100%;display:block}
    .meta{font-size:13px;color:var(--muted);margin-top:8px}

    .hint{font-size:13px;color:var(--muted);margin-top:10px}

    /* Responsive */
    @media (max-width:880px){
      .workspace{grid-template-columns:1fr}
      .sidebar{order:2}
      .canvas-wrap{min-height:240px}
    }

    /* small handles for resize */
    .handle{position:absolute;width:18px;height:18px;background:var(--bg);border:3px solid var(--blue);border-radius:4px;box-shadow:0 2px 6px rgba(11,94,215,0.12);pointer-events:auto}
    .handle.tl{cursor:nwse-resize}
    .handle.tr{cursor:nesw-resize}
    .handle.bl{cursor:nesw-resize}
    .handle.br{cursor:nwse-resize}

    /* caption input */
    .caption{width:100%;padding:10px;border-radius:8px;border:1px solid #e6eefc;margin-top:10px}

    .small{font-size:13px}
    footer{margin-top:14px;color:var(--muted);font-size:13px;text-align:center}
  </style>
</head>
<body>
  <div class="app">
    <div class="card">
      <header>
        <div class="logo">
          <span class="dot" aria-hidden></span>
          <div>
            <h1>Tools Jet — Meme Generator</h1>
            <p class="lead">Upload an image, crop, preview and download — mobile-ready.</p>
          </div>
        </div>
      </header>

      <div class="controls">
        <div class="file-input">
          <label for="fileInput" class="file-label">Upload Image</label>
          <input id="fileInput" type="file" accept="image/*">
          <button id="clearBtn" class="btn ghost">Clear</button>
        </div>

        <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
          <button id="previewBtn" class="btn">Preview Crop</button>
          <button id="downloadBtn" class="btn" disabled>Download</button>
        </div>
      </div>

      <div class="workspace">
        <div>
          <div class="canvas-wrap card" id="canvasWrap">
            <canvas id="imageCanvas"></canvas>
            <!-- overlay interactive selection area created with DOM so it's easy to handle touch/mouse -->
            <div class="overlay" id="overlay"></div>
          </div>
          <p class="hint small">Drag the corners of the selection to resize. Drag inside the selection to move it. Works with touch and mouse.</p>
        </div>

        <aside class="sidebar">
          <div class="preview" style="min-height:180px">
            <canvas id="previewCanvas" width="300" height="180"></canvas>
          </div>
          <div class="meta">
            <div>Cropped size: <span id="cropSize">—</span></div>
            <div>Original image: <span id="origSize">—</span></div>
          </div>

          <input id="caption" class="caption" placeholder="Optional: Add a caption (not burned-in)" />
        </aside>
      </div>

      <footer>Made for Tools Jet • Bright blue &amp; white theme</footer>
    </div>
  </div>


  <script>
    // Basic interactive crop selection using a DOM element overlay with handles.
    const fileInput = document.getElementById('fileInput');
    const imageCanvas = document.getElementById('imageCanvas');
    const previewCanvas = document.getElementById('previewCanvas');
    const overlay = document.getElementById('overlay');
    const previewBtn = document.getElementById('previewBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const clearBtn = document.getElementById('clearBtn');
    const cropSizeEl = document.getElementById('cropSize');
    const origSizeEl = document.getElementById('origSize');
    const captionInput = document.getElementById('caption');

    let img = new Image();
    let imgLoaded = false;

    const ctx = imageCanvas.getContext('2d');
    const pctx = previewCanvas.getContext('2d');

    // selection state (in imageCanvas coordinate space)
    const sel = {x:50,y:50,w:150,h:120};
    let dragging = false;
    let dragType = null; // 'move' or 'resize'
    let dragHandle = null;
    let start = {};

    function resetState(){
      imgLoaded = false;
      ctx.clearRect(0,0,imageCanvas.width,imageCanvas.height);
      overlay.innerHTML='';
      previewCropToCanvas(null);
      downloadBtn.disabled = true;
      cropSizeEl.textContent='—';
      origSizeEl.textContent='—';
    }

    clearBtn.addEventListener('click',()=>{fileInput.value=''; resetState();});

    fileInput.addEventListener('change',e=>{
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      const url = URL.createObjectURL(f);
      img = new Image();
      img.onload = ()=>{
        imgLoaded = true;
        origSizeEl.textContent = img.width + '×' + img.height;
        // Fit canvas to container width while preserving image aspect
        const containerW = Math.min(900, document.querySelector('.canvas-wrap').clientWidth - 24);
        const scale = containerW / img.width;
        imageCanvas.width = Math.round(img.width * scale);
        imageCanvas.height = Math.round(img.height * scale);
        // When drawing scaled image, keep an internal scale factor for coordinates
        imageCanvas.dataset.scalef = scale;
        ctx.clearRect(0,0,imageCanvas.width,imageCanvas.height);
        ctx.drawImage(img,0,0,imageCanvas.width,imageCanvas.height);

        // initialize selection to center
        sel.w = Math.min(imageCanvas.width * 0.6, imageCanvas.width-20);
        sel.h = Math.min(imageCanvas.height * 0.5, imageCanvas.height-20);
        sel.x = Math.round((imageCanvas.width - sel.w)/2);
        sel.y = Math.round((imageCanvas.height - sel.h)/2);

        renderOverlay();
        downloadBtn.disabled = false;
      };
      img.src = url;
    });

    function renderOverlay(){
      // clear draw of canvas underlying image (redraw image)
      ctx.clearRect(0,0,imageCanvas.width,imageCanvas.height);
      ctx.drawImage(img,0,0,imageCanvas.width,imageCanvas.height);

      // draw dimmed area outside selection
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.beginPath();
      ctx.rect(0,0,imageCanvas.width,imageCanvas.height);
      ctx.rect(sel.x,sel.y,sel.w,sel.h);
      ctx.fill('evenodd');
      ctx.restore();

      // border
      ctx.save();
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.strokeRect(sel.x+1,sel.y+1,sel.w-2,sel.h-2);
      ctx.restore();

      // draw handles
      overlay.innerHTML = '';
      const handles = ['tl','tr','bl','br'];
      const positions = {
        tl:[sel.x,sel.y], tr:[sel.x+sel.w-18,sel.y], bl:[sel.x,sel.y+sel.h-18], br:[sel.x+sel.w-18,sel.y+sel.h-18]
      };
      handles.forEach(h=>{
        const div = document.createElement('div');
        div.className = 'handle '+h;
        div.style.left = positions[h][0] + 'px';
        div.style.top  = positions[h][1] + 'px';
        div.dataset.handle = h;
        overlay.appendChild(div);
      });

      // selection info
      cropSizeEl.textContent = Math.round(sel.w / imageCanvas.dataset.scalef) + '×' + Math.round(sel.h / imageCanvas.dataset.scalef);
    }

    // Utility to get event position relative to canvas (client -> canvas coords)
    function getPosFromEvent(e){
      const rect = imageCanvas.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      return {
        x: Math.round(clientX - rect.left),
        y: Math.round(clientY - rect.top)
      };
    }

    // Mouse / touch handlers on overlay (we attach to document to track dragging outside area)
    overlay.addEventListener('pointerdown', (e)=>{
      if(!imgLoaded) return;
      const target = e.target;
      const pos = getPosFromEvent(e);
      start.x = pos.x; start.y = pos.y;
      start.sel = {...sel};

      if(target.classList.contains('handle')){
        dragType = 'resize';
        dragHandle = target.dataset.handle;
      } else {
        // inside move?
        if(pos.x >= sel.x && pos.x <= sel.x+sel.w && pos.y >= sel.y && pos.y <= sel.y+sel.h){
          dragType = 'move';
        } else {
          // clicked outside selection: reposition selection centered at pointer
          sel.x = Math.max(0, Math.min(imageCanvas.width - sel.w, pos.x - sel.w/2));
          sel.y = Math.max(0, Math.min(imageCanvas.height - sel.h, pos.y - sel.h/2));
          renderOverlay();
          return;
        }
      }
      overlay.setPointerCapture(e.pointerId);
    });

    overlay.addEventListener('pointermove', (e)=>{
      if(!dragType || !imgLoaded) return;
      const pos = getPosFromEvent(e);
      const dx = pos.x - start.x;
      const dy = pos.y - start.y;
      if(dragType === 'move'){
        sel.x = Math.max(0, Math.min(imageCanvas.width - sel.w, start.sel.x + dx));
        sel.y = Math.max(0, Math.min(imageCanvas.height - sel.h, start.sel.y + dy));
      } else if(dragType === 'resize'){
        // depending on handle change x,y,w,h
        const minSize = 30;
        if(dragHandle === 'tl'){
          const nx = Math.min(start.sel.x + start.sel.w - minSize, start.sel.x + dx);
          const ny = Math.min(start.sel.y + start.sel.h - minSize, start.sel.y + dy);
          sel.w = start.sel.w + (start.sel.x - nx);
          sel.h = start.sel.h + (start.sel.y - ny);
          sel.x = nx; sel.y = ny;
        }
        if(dragHandle === 'tr'){
          const nxw = Math.max(minSize, start.sel.w + dx);
          const nyh = Math.min(start.sel.y + start.sel.h - minSize, start.sel.y + dy);
          sel.w = nxw;
          sel.h = start.sel.h + (start.sel.y - nyh);
          sel.y = nyh;
        }
        if(dragHandle === 'bl'){
          const nx = Math.min(start.sel.x + start.sel.w - minSize, start.sel.x + dx);
          const nhw = start.sel.w + (start.sel.x - nx);
          const nh = Math.max(minSize, start.sel.h + dy);
          sel.x = nx; sel.w = nhw; sel.h = nh;
        }
        if(dragHandle === 'br'){
          sel.w = Math.max(30, start.sel.w + dx);
          sel.h = Math.max(30, start.sel.h + dy);
        }
        // clamp to canvas
        sel.w = Math.min(sel.w, imageCanvas.width - sel.x);
        sel.h = Math.min(sel.h, imageCanvas.height - sel.y);
        sel.x = Math.max(0, sel.x);
        sel.y = Math.max(0, sel.y);
      }
      renderOverlay();
    });

    overlay.addEventListener('pointerup', (e)=>{dragType=null;dragHandle=null;overlay.releasePointerCapture(e.pointerId);});
    overlay.addEventListener('pointercancel', (e)=>{dragType=null;dragHandle=null;});

    // Preview crop: draws cropped area (in original-image pixel size) into preview canvas
    function previewCropToCanvas(blobOrNull){
      if(!imgLoaded){
        pctx.clearRect(0,0,previewCanvas.width,previewCanvas.height);
        return;
      }
      const scale = parseFloat(imageCanvas.dataset.scalef || 1);
      // Calculate source rect in original image pixels
      const sx = Math.round(sel.x / scale);
      const sy = Math.round(sel.y / scale);
      const sw = Math.round(sel.w / scale);
      const sh = Math.round(sel.h / scale);

      // Resize preview canvas to maintain aspect ratio but fit sidebar
      const maxW = 320; const maxH = 220;
      let pw = sw; let ph = sh;
      const r = Math.min(maxW / pw, maxH / ph, 1);
      pw = Math.round(pw * r); ph = Math.round(ph * r);
      previewCanvas.width = pw; previewCanvas.height = ph;
      pctx.clearRect(0,0,pw,ph);
      // draw from original image (img is original image object)
      pctx.drawImage(img, sx, sy, sw, sh, 0, 0, pw, ph);
    }

    previewBtn.addEventListener('click', ()=>{
      if(!imgLoaded) return alert('Upload an image first');
      previewCropToCanvas();
    });

    // Download: create final cropped image at original image pixel size and trigger download
    downloadBtn.addEventListener('click', ()=>{
      if(!imgLoaded) return;
      const scale = parseFloat(imageCanvas.dataset.scalef || 1);
      const sx = Math.round(sel.x / scale);
      const sy = Math.round(sel.y / scale);
      const sw = Math.round(sel.w / scale);
      const sh = Math.round(sel.h / scale);

      // create offscreen canvas at target size
      const out = document.createElement('canvas');
      out.width = sw; out.height = sh;
      const outCtx = out.getContext('2d');
      // draw the crop from the original image
      outCtx.drawImage(img, sx, sy, sw, sh, 0, 0, sw, sh);

      // Optional: draw caption text on top (not required). This example leaves it off. If you want caption burned in, uncomment:
      const caption = captionInput.value.trim();
      if(caption){
        outCtx.font = Math.max(18, Math.floor(sw/14)) + 'px sans-serif';
        outCtx.textAlign = 'center';
        outCtx.fillStyle = 'white';
        outCtx.strokeStyle = 'black';
        outCtx.lineWidth = Math.max(3, Math.floor(sw/200));
        const y = out.height - 18;
        outCtx.strokeText(caption, out.width/2, y);
        outCtx.fillText(caption, out.width/2, y);
      }

      out.toBlob((blob)=>{
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'meme.png';
        document.body.appendChild(a);
        a.click();
        a.remove();
      }, 'image/png');
    });

    // redraw overlay when window resizes (scale image to container while preserving original scale fraction)
    window.addEventListener('resize', ()=>{
      if(!imgLoaded) return;
      const oldScale = parseFloat(imageCanvas.dataset.scalef || 1);
      const containerW = Math.min(900, document.querySelector('.canvas-wrap').clientWidth - 24);
      const newScale = containerW / img.width;
      // compute sel in original pixels then re-apply scaled
      const origSel = {
        x: Math.round(sel.x / oldScale),
        y: Math.round(sel.y / oldScale),
        w: Math.round(sel.w / oldScale),
        h: Math.round(sel.h / oldScale)
      };
      imageCanvas.width = Math.round(img.width * newScale);
      imageCanvas.height = Math.round(img.height * newScale);
      imageCanvas.dataset.scalef = newScale;
      // set selection back scaled
      sel.x = Math.round(origSel.x * newScale);
      sel.y = Math.round(origSel.y * newScale);
      sel.w = Math.round(origSel.w * newScale);
      sel.h = Math.round(origSel.h * newScale);
      renderOverlay();
    });

    // Init: clear
    resetState();
  </script>
</body>
</html>

